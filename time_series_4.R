datas <- dbGetQuery(conn = con, statement = "select s.INTERVALLE + (s.JOUR - 1) * 288 as INTERVALLE, avg(s.DISPONIBLES) as DISPONIBLES  from station s where s.ID_STATION = '3003' and s.DATE between '2016-04-01' and '2016-04-07' group by s.JOUR, s.INTERVALLE order by s.ID;")
s3003 <- data.frame(datas)
inte <- seq(from = min(s3003$INTERVALLE), to = max(s3003$INTERVALLE), by = 5)
inte <- data.frame(inte)
merge <- merge(inte, s3003, by.x=names(inte)[1], by.y="INTERVALLE", all.x = TRUE)
merge <- na.locf(merge)
s1 <- ts(data = merge$DISPONIBLES, start = min(merge$inte), end = max(merge$inte), frequency = 1/5)
plot(s1)
fit.arima<-arima(s1, order=c(2,0,2))
fcast.arima <- forecast(fit.arima)
plot(fcast.arima)
fcast.arima <- forecast(fit.arima, h=50)
plot(fcast.arima)
fcast.arima <- forecast(fit.arima, h=12)
plot(fcast.arima)
fit <- auto.arima(s1)
fcast <- forecast(fit)
plot(fcast)
plot(fcast)
fit <- auto.arima(s1, h=12)
fcast <- forecast(fit)
plot(fcast)
fit <- auto.arima(s1)
fcast <- forecast(fit, h=12)
plot(fcast)
fit <- auto.arima(s1)
fcast <- forecast(fit, h=12)
plot(fcast)
fit <- auto.arima(s1)
fcast <- forecast(fit, h=50)
plot(fcast)
datas <- dbGetQuery(conn = con, statement = "select s.INTERVALLE + (s.JOUR - 1) * 288 as INTERVALLE, min(s.DATE) as DATE, avg(s.DISPONIBLES) as DISPONIBLES  from station s where s.ID_STATION = '3003' and s.DATE between '2016-04-01' and '2016-04-07' group by s.JOUR, s.INTERVALLE order by s.ID;")
s3003 <- data.frame(datas)
inte <- seq(from = min(s3003$INTERVALLE), to = max(s3003$INTERVALLE), by = 5)
inte <- data.frame(inte)
merge <- merge(inte, s3003, by.x=names(inte)[1], by.y="INTERVALLE", all.x = TRUE)
merge <- na.locf(merge)
head(merge)
min(merge$inte)
max(merge$inte)
s3003
head(s3003)
datas <- dbGetQuery(conn = con, statement = "select s.INTERVALLE + (s.JOUR - 1) * 288 as INTERVALLE, avg(s.DISPONIBLES) as DISPONIBLES  from station s where s.ID_STATION = '3003' and s.DATE between '2016-04-01' and '2016-04-07' group by s.JOUR, s.INTERVALLE order by s.ID;")
s3003 <- data.frame(datas)
inte <- seq(from = min(s3003$INTERVALLE), to = max(s3003$INTERVALLE))
inte <- data.frame(inte)
merge <- merge(inte, s3003, by.x=names(inte)[1], by.y="INTERVALLE", all.x = TRUE)
merge <- na.locf(merge)
s1 <- ts(data = merge$DISPONIBLES, start = min(merge$inte), end = max(merge$inte), frequency = 1)
plot(s1)
fit.arima<-arima(s1, order=c(2,0,2))
fcast.arima <- forecast(fit.arima)
plot(fcast.arima)
fcast.arima <- forecast(fit.arima, h=12)
plot(fcast.arima)
fcast.arima <- forecast(fit.arima, h=120)
plot(fcast.arima)
library(forecast)
library(RMySQL)
library(zoo)
con <- dbConnect(MySQL(), user = 'root', password = 'root', host = 'localhost', dbname='test')
datas <- dbGetQuery(conn = con, statement = "select s.INTERVALLE + (s.JOUR - 1) * 288 as INTERVALLE, min(s.DATE), avg(s.DISPONIBLES) as DISPONIBLES  from station s where s.ID_STATION = '3003' and s.DATE between '2016-04-01' and '2016-04-07' group by s.JOUR, s.INTERVALLE order by s.ID;")
head(datas)
s3003 <- data.frame(datas)
inte <- seq(from = min(s3003$INTERVALLE), to = max(s3003$INTERVALLE))
nrows(inte)
nrow(inte)
inte <- data.frame(inte)
nrow(inte)
merge <- merge(inte, s3003, by.x=names(inte)[1], by.y="INTERVALLE", all.x = TRUE)
merge <- na.locf(merge)
head(merge)
merge[,1]
merge[1,]
d <- merge[1,]$min.s.DATE.
d
as.Date(as.character(d),format="%Y%m%d %H:%M:%S")
as.Date(as.character(d),format="%Y%m%d %H:%M:%S")
as.Date(as.character(d),format="%Y-%m-%d %H:%M:%S")
as.POSIXct(as.character(d),format="%Y-%m-%d %H:%M:%S")
as.POSIXct(as.character(d),format="%Y-%m-%d %H:%M:%s")
as.POSIXct(d,format="%Y-%m-%d %H:%M:%s")
as.POSIXct(d,format="%Y-%m-%d %H:%M:%S")
merge$date <- as.POSIXct(merge$min.s.DATE.,format="%Y-%m-%d %H:%M:%S")
mergehead())
head(merge)
install.packages("xts")
library(xts)
TS <- xts(x=merge$DISPONIBLES,order.by=merge$date)
plot(TS)
dec <- decompose(TS)
s1 <- ts(data = merge$DISPONIBLES, start = min(merge$date), end = max(merge$date), frequency = 1)
help(ts)
savehistory("time_series_3.R")
library(RMySQL)
library(zoo)
library(forecast)
con <- dbConnect(MySQL(), user = 'root', password = 'root', host = 'localhost', dbname='test')
datas <- dbGetQuery(conn = con, statement = "SELECT s.INTERVALLE,  IF(s.INTERVALLE < @a, @b:=@b+1, @b) as VALUE_B,  s.INTERVALLE + 288 * @b AS INTERVALLE, MIN(s.DATE) AS DATE, AVG(s.DISPONIBLES) AS DISPONIBLES, @a := s.INTERVALLE as previous FROM station s, (select @a:= 1, @b:=0) as init WHERE s.ID_STATION = '3003'  AND s.DATE BETWEEN '2016-02-27' AND '2016-04-08' GROUP BY s.JOUR , s.INTERVALLE ORDER BY s.ID;")
s3003 <- data.frame(datas)
inte <- seq(from = min(s3003$INTERVALLE), to = max(s3003$INTERVALLE))
inte <- data.frame(inte)
merge <- merge(inte, s3003, by.x=names(inte)[1], by.y="INTERVALLE", all.x = TRUE)
merge <- na.locf(merge)
s1 <- ts(data = merge$DISPONIBLES, start = min(merge$date), end = max(merge$date), frequency = 1)
s1 <- ts(data = merge$DISPONIBLES, start = min(merge$inte), end = max(merge$inte), frequency = 1)
head(merge)
summary(merge$inte)
max(merge$inte)
summary(merge)
max(s3003$INTERVALLE)
summary(s3003)
datas <- dbGetQuery(conn = con, statement = "SELECT IF(s.INTERVALLE < @a, @b:=@b+1, @b) as VALUE_B,  s.INTERVALLE + 288 * @b AS INTERVALLE, MIN(s.DATE) AS DATE, AVG(s.DISPONIBLES) AS DISPONIBLES, @a := s.INTERVALLE as previous FROM station s, (select @a:= 1, @b:=0) as init WHERE s.ID_STATION = '3003'  AND s.DATE BETWEEN '2016-02-27' AND '2016-04-08' GROUP BY s.JOUR , s.INTERVALLE ORDER BY s.ID;")
s3003 <- data.frame(datas)
inte <- seq(from = min(s3003$INTERVALLE), to = max(s3003$INTERVALLE))
inte <- data.frame(inte)
merge <- merge(inte, s3003, by.x=names(inte)[1], by.y="INTERVALLE", all.x = TRUE)
merge <- na.locf(merge)
s1 <- ts(data = merge$DISPONIBLES, start = min(merge$inte), end = max(merge$inte), frequency = 1)
plot(s1)
max(merge$inte)
s1 <- ts(data = merge$DISPONIBLES, start = as.numeric(min(merge$inte)), end = as.numeric(max(merge$inte)), frequency = 1)
plot(s1)
fit.arima<-arima(s1, order=c(2,0,2))
s1
head(s1)
summary(s1)
s1 <- ts(data = merge$DISPONIBLES, start = as.numeric(min(merge$inte)), end = as.numeric(max(merge$inte)), frequency = 1)
fit.arima<-arima(s1, order=c(2,0,2))
fit <- auto.arima(s1)
summary(merge$DISPONIBLES)
s1 <- ts(data = as.numeric(merge$DISPONIBLES), start = as.numeric(min(merge$inte)), end = as.numeric(max(merge$inte)), frequency = 1)
plot(s1)
fit <- auto.arima(s1)
fcast <- forecast(fit)
plot(fcast)
fcast <- forecast(fit, h=50)
plot(fcast)
fcast <- forecast(fit, h=150)
plot(fcast)
fcast <- forecast(fit, h=250)
plot(fcast)
fcast <- forecast(fit, h=550)
plot(fcast)
datas <- dbGetQuery(conn = con, statement = "SELECT IF(s.INTERVALLE < @a, @b:=@b+1, @b) as VALUE_B,  s.INTERVALLE + 288 * @b AS INTERVALLE, MIN(s.DATE) AS DATE, AVG(s.DISPONIBLES) AS DISPONIBLES, @a := s.INTERVALLE as previous FROM station s, (select @a:= 1, @b:=0) as init WHERE s.ID_STATION = '3003'  AND s.DATE BETWEEN '2016-02-27' AND '2016-04-07 12:00' GROUP BY s.JOUR , s.INTERVALLE ORDER BY s.ID;")
s3003 <- data.frame(datas)
inte <- seq(from = min(s3003$INTERVALLE), to = max(s3003$INTERVALLE), by = 5)
inte <- data.frame(inte)
merge <- merge(inte, s3003, by.x=names(inte)[1], by.y="INTERVALLE", all.x = TRUE)
merge <- na.locf(merge)
s1 <- ts(data = as.numeric(merge$DISPONIBLES), start = as.numeric(min(merge$inte)), end = as.numeric(max(merge$inte)), frequency = 1)
plot(s1)
inte <- seq(from = min(s3003$INTERVALLE), to = max(s3003$INTERVALLE), by = 1)
inte <- data.frame(inte)
merge <- merge(inte, s3003, by.x=names(inte)[1], by.y="INTERVALLE", all.x = TRUE)
merge <- na.locf(merge)
s1 <- ts(data = as.numeric(merge$DISPONIBLES), start = as.numeric(min(merge$inte)), end = as.numeric(max(merge$inte)), frequency = 1)
plot(s1)
fcast <- forecast(fit, h=250)
plot(fcast)
plot(s1)
plot(fcast)
fit <- auto.arima(s1)
fcast <- forecast(fit, h=250)
plot(fcast)
setwd("C:/projet/velov/scripts")
savehistory("time_series_4.R")
